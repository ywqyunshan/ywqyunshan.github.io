<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    <meta property="og:site_name" content="FQ Blog">
    <meta property="og:type" content="article">

    
    <meta property="og:image" content="https://ywqyunshan.github.io//img/home-bg-jeep.jpg">
    <meta property="twitter:image" content="https://ywqyunshan.github.io//img/home-bg-jeep.jpg" />
    

    
    <meta name="title" content="Android图形系统-窗口子系统-窗口" />
    <meta property="og:title" content="Android图形系统-窗口子系统-窗口" />
    <meta property="twitter:title" content="Android图形系统-窗口子系统-窗口" />
    

    
    <meta name="description" content="">
    <meta property="og:description" content="" />
    <meta property="twitter:description" content="" />
    

    
    <meta property="twitter:card" content="summary" />
    
    

    <meta name="keyword"  content="iigeoywq, button, 博客, 个人网站, 图形学, GIS, 座舱, 车载, Andorid, 系统">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>Android图形系统-窗口子系统-窗口 | </title>

    <link rel="canonical" href="/2023/02/04/">

    
    
    
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    
    <link rel="stylesheet" href="/css/hugo-theme-cleanwhite.min.css">

    
    <link rel="stylesheet" href="/css/zanshang.css">

    
    <link href="https://cdn.jsdelivr.net/gh/FortAwesome/Font-Awesome@5.15.1/css/all.css" rel="stylesheet" type="text/css">

    
    

    
    <script src="/js/jquery.min.js"></script>

    
    <script src="/js/bootstrap.min.js"></script>

    
    <script src="/js/hux-blog.min.js"></script>

    
    <script src="/js/lazysizes.min.js"></script>

    
    

</head>






<nav class="navbar navbar-default navbar-custom navbar-fixed-top">

    <div class="container-fluid">
        
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">FQ Blog</a>
        </div>

        
        
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">All Posts</a>
                    </li>
                    
                        
                        <li>
                            <a href="/categories/tech">tech</a>
                        </li>
                        
                    
                    
		    
                        <li><a href="/archive/">ARCHIVE</a></li>
                    
                        <li><a href="/notes/">NOTES</a></li>
                    
                        <li><a href="/about/">ABOUT</a></li>
                    
		            <li>
                        <a href="/search"><i class="fa fa-search"></i></a>
		           </li>
                </ul>
            </div>
        </div>
        
    </div>
    
</nav>
<script>
    
    
    
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        
            $navbar.className = " ";
            
            setTimeout(function(){
                
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>




<style type="text/css">
    header.intro-header {
        background-image: url('/img/home-bg-jeep.jpg')
    }
</style>

<header class="intro-header" >

    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/tags/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA" title="系统理论">
                            系统理论
                        </a>
                        
                    </div>
                    <h1>Android图形系统-窗口子系统-窗口</h1>
                    <h2 class="subheading">窗口管理</h2>
                    <span class="meta">
                        
                            Posted by 
                            
                                    &#34;iigeoywq button&#34;
                             
                            on 
                            Saturday, February 4, 2023
                            
                            
                            
                            
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>




<article>
    <div class="container">
        <div class="row">

            
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                
                <blockquote>
<p>对于图形系统而言，
首先要有一个窗口（自上而下每层对应的概念不同），接下来在窗口中申请buffer并渲染，最后合成图层并送显，本篇主要讲一下，如何获取一个窗口，以及合成时创建HWC2：Layer的流程。</p>
</blockquote>
<h2 id="一-窗口子系统窗口架构">一 窗口子系统（窗口）架构</h2>
<p>Android中的窗口是个抽象概念：本质上是一块画布，但是没有申请buffer，绘制的时候才会申请buffer，但是合成的时候，是已经渲染完成的layer（见渲染篇的代码分析）。</p>
<p>纵向来说每层都有个对应的概念，依次为Window(抽象概念）&ndash;&gt;WindowState&ndash;&gt;Surface&ndash;&gt;Layer&ndash;&gt;hwc2_layer_t
注意：SurfaceView不走WMS创建Surface，直接Jni调用Native Client端创建surface。暂不讨论。</p>
<ul>
<li>
<p>应用层：有二种抽象类型</p>
<ul>
<li>Phonewindow：每个Acitivity对应一个PhoneWindow，但是它是个抽象，具体的实现是DecorView，DecorView是一个Acitivity最顶层的View，在WMS测WindowManager.addView()方法添加的view就是DecorView。</li>
<li>系统级的窗口:例如状态栏，没有PhoneWindow概念，本质上是一个view，在WMS测WindowManager.addView()方法直接添加该View。</li>
</ul>
</li>
<li>
<p>Java Framework层：
对应创建windowState和应用层的window对应，但是SurfaceView没有这个概念。</p>
</li>
<li>
<p>Native Framework层：</p>
<ul>
<li>client：Surface/ANativeWindow</li>
<li>server（SurfaceFligner）：Layer</li>
</ul>
</li>
<li>
<p>Hal层:</p>
<ul>
<li>client：HWC2::Layer</li>
<li>server：HWCLayer::hwc2_layer_t</li>
</ul>
</li>
<li>
<p>内核层：Drm-&gt;KMS-&gt;plane</p>
</li>
</ul>
<p>总的来说，Android中的Window对应的是native测的Surface/Layer。</p>
<h2 id="二-源码目录">二 源码目录</h2>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-lboi{border-color:inherit;text-align:left;vertical-align:middle}
.tg .tg-uzvj{border-color:inherit;font-weight:bold;text-align:center;vertical-align:middle}
.tg .tg-7btt{border-color:inherit;font-weight:bold;text-align:center;vertical-align:top}
.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
</style>
<table class="tg" style="undefined;table-layout: fixed; width: 1530px">
<colgroup>
<col style="width: 100.333333px">
<col style="width: 116.333333px">
<col style="width: 366.333333px">
<col style="width: 311.333333px">
<col style="width: 68.333333px">
<col style="width: 162.333333px">
<col style="width: 284.333333px">
<col style="width: 120.333333px">
</colgroup>
<thead>
  <tr>
    <th class="tg-uzvj" colspan="2" rowspan="2">模块</th>
    <th class="tg-7btt" colspan="2">源码路径</th>
    <th class="tg-uzvj">进程</th>
    <th class="tg-7btt" colspan="2">类库</th>
    <th class="tg-uzvj" rowspan="2">备注</th>
  </tr>
  <tr>
    <th class="tg-uzvj">Android实现</th>
    <th class="tg-uzvj">厂商（高通）实现</th>
    <th class="tg-0pky"></th>
    <th class="tg-uzvj">Android</th>
    <th class="tg-uzvj">厂商（高通）</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0pky" colspan="2">APP层</td>
    <td class="tg-0pky" colspan="2"></td>
    <td class="tg-0pky" rowspan="2">同属一个进程</td>
    <td class="tg-0pky" colspan="2">APK</td>
    <td class="tg-0pky"></td>
  </tr>
  <tr>
    <td class="tg-lboi" rowspan="3">Java Framework层</td>
    <td class="tg-0pky">Client</td>
    <td class="tg-0pky" colspan="2">frameworks/base/core/java/android/app/Activity.java<br>frameworks/base/core/java/android/view/ViewRootImpl.java<br>frameworks/base/core/java/com/android/internal/policy/DecorView.java</td>
    <td class="tg-0pky" colspan="2">system/framework/framework.jar</td>
    <td class="tg-0pky"></td>
  </tr>
  <tr>
    <td class="tg-0pky">Server-AMS</td>
    <td class="tg-0pky" colspan="2">frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</td>
    <td class="tg-0pky"></td>
    <td class="tg-0pky" colspan="2" rowspan="2">system/framework/service.jar</td>
    <td class="tg-0pky"></td>
  </tr>
  <tr>
    <td class="tg-0pky">Server-WMS</td>
    <td class="tg-0pky" colspan="2">frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java<br>frameworks/base/services/core/java/com/android/server/wm/WindowState.java<br></td>
    <td class="tg-0pky" rowspan="3">同属一个进程</td>
    <td class="tg-0pky"></td>
  </tr>
  <tr>
    <td class="tg-lboi" rowspan="3">Native Framework层<br></td>
    <td class="tg-0pky">Jni</td>
    <td class="tg-0pky" colspan="2">frameworks/base/core/jni/android_view_Surface.cpp<br>frameworks/base/core/jni/android_view_SurfaceControl.cpp<br>frameworks/base/core/jni/android_view_SurfaceSession.cpp<br></td>
    <td class="tg-0pky" colspan="2">/system/lib64/libandroid_runtime.so</td>
    <td class="tg-0pky"></td>
  </tr>
  <tr>
    <td class="tg-0pky">Client</td>
    <td class="tg-0pky" colspan="2">frameworks/native/libs/gui/Surface.cpp<br>frameworks/native/libs/gui/SurfaceControl.cpp<br>frameworks/native/libs/gui/SurfaceComposerClient.cppframeworks/native/libs/gui/SurfaceControl.cpp</td>
    <td class="tg-0pky" colspan="2">system/lib64/libgui.so</td>
    <td class="tg-0pky"></td>
  </tr>
  <tr>
    <td class="tg-0pky">Server-SurfaceFilnger</td>
    <td class="tg-0pky" colspan="2">frameworks/native/services/surfaceflinger/Layer.cpp<br>frameworks/native/services/surfaceflinger/Client.cpp<br></td>
    <td class="tg-0pky" rowspan="2">同一个进程</td>
    <td class="tg-0pky" colspan="2" rowspan="2">/system/bin/surfaceflinger</td>
    <td class="tg-0pky"></td>
  </tr>
  <tr>
    <td class="tg-0pky" rowspan="4">Hal层</td>
    <td class="tg-0pky">Client</td>
    <td class="tg-0pky" colspan="2">frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp (HWC1)<br>/frameworks/native/services/surfaceflinger/DisplayHardware/HWC2.cpp (HWC2)<br></td>
    <td class="tg-0pky"></td>
  </tr>
  <tr>
    <td class="tg-0pky">Server-HWC</td>
    <td class="tg-0pky" colspan="2">hardware/interfaces/graphics/composer/2.1/default<br></td>
    <td class="tg-0pky"></td>
    <td class="tg-0pky" colspan="2">vendor/lib64/android.hardware.graphics.composer@2.1.so<br>vendor/lib64/hw/android.hardware.graphics.composer@2.1-impl.so<br>vendor/bin/hw/android.hardware.graphics.composer@2.1-service<br></td>
    <td class="tg-0pky"></td>
  </tr>
  <tr>
    <td class="tg-0pky">hwc实现</td>
    <td class="tg-0pky">hardware/libhardware/modules/hwcomposer/hwcomposer.cpp（HWC1）<br>external/drm_hwcomposer/（HWC2 三方开源实现）</td>
    <td class="tg-0pky">hardware/qcom/display/msm8226/libhwcomposer/hwc.cpp(HWC1)<br><br>hardware/qcom/sdm845/display/sdm/libs/hwc2/(HWC2)</td>
    <td class="tg-0pky"></td>
    <td class="tg-0pky">hwcomposer.default.so(HWC1)<br>hwcomposer.drm.so(HWC2)</td>
    <td class="tg-0pky">vendor/lib64/hw/hwcomposer.msmxxx,so(HWC1)<br>vendor/lib64/hw/hwcomposer.sdmxxx.so(HWC2)</td>
    <td class="tg-0pky">高通的so都是闭源的，高通只开放了部分源码仅供参考，以高通官方文档为准</td>
  </tr>
  <tr>
    <td class="tg-0pky">drm接口层</td>
    <td class="tg-0pky" colspan="2">external/libdrm/libkms/</td>
    <td class="tg-0pky"></td>
    <td class="tg-0pky" colspan="2">vendor/lib64/libdrm.so</td>
    <td class="tg-0pky"></td>
  </tr>
  <tr>
    <td class="tg-0pky">内核层</td>
    <td class="tg-0pky">DRM-KMS</td>
    <td class="tg-0pky">待确定</td>
    <td class="tg-0pky">common/drivers/gpu/drm/msm/</td>
    <td class="tg-0pky"></td>
    <td class="tg-0pky">待确定</td>
    <td class="tg-0pky">待确定</td>
    <td class="tg-0pky"></td>
  </tr>
</tbody>
</table>
<p>Android8以后默认HWC2接口实现，所以忽略HWC1的分析。</p>
<h2 id="三-源码分析">三 源码分析</h2>
<p>接下来自上而下分析Android中Activity抽象窗口如何创建。篇幅有限，只梳理关键部分。</p>
<h3 id="31-app进程创建">3.1 App进程创建</h3>
<p>首先需要创建一个app进程，并创建Activity，参考这篇文章
<a href="https://www.jianshu.com/p/37370c1d17fc">Android应用启动全流程分析</a>4到6节。</p>
<h3 id="32-surface和layer创建">3.2 Surface和Layer创建</h3>
<p>先小结一下，Java测的Surface对象是一个序列化对象，App进程和WMS进程共用，app进程将surface对象aidl声明为out的方式，传入wms进程，通过jni调用native测进程创建后，回传app进程。</p>
<h4 id="321-向系统申请app类型的vsync信号">3.2.1 向系统申请app类型的vsync信号</h4>
<p>接3.1 来到Activity创建后的，经过下面流程WMS添加view到窗口。引用沧浪之水的一张图看一下。

  <img src="/img/WMS%E6%B7%BB%E5%8A%A0window.jpg" alt="WMS添加Window过程">


接上图来到ViewRootImpl的setView方法，最终会向系统申请app类型的vsync信号。</p>
<pre><code>/*frameworks/base/core/java/android/view/WindowManagerGlobal.java*/
public void addView(...) {
     // 创建ViewRootImpl对象
     root = new ViewRootImpl(view.getContext(), display);
     ...
     try {
         // 执行ViewRootImpl的setView函数
         root.setView(view, wparams, panelParentView, userId);
     } catch (RuntimeException e) {
         ...
     } 
}

/*frameworks/base/core/java/android/view/ViewRootImpl.java*/
public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView,
            int userId) {
      synchronized (this) {
         if (mView == null) {
             mView = view;
         }
         ...
         // 开启绘制硬件加速，初始化RenderThread渲染线程运行环境
         enableHardwareAcceleration(attrs);
         ...
         // 触发绘制动作
         requestLayout();
}
/*frameworks/base/core/java/android/view/ViewRootImpl.java*/
public void requestLayout() {
    if (!mHandlingLayoutInLayoutRequest) {
         // 检查当前UI绘制操作是否发生在主线程，如果发生在子线程则会抛出异常
         checkThread();
         mLayoutRequested = true;
         // 触发绘制操作
         scheduleTraversals();
    }
}

@UnsupportedAppUsage
void scheduleTraversals() {
    if (!mTraversalScheduled) {
         ...
         // 注意此处会往主线程的MessageQueue消息队列中添加同步栏删，因为系统绘制消息属于异步消息，需要更高优先级的处理
         mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();
         // 通过Choreographer往主线程消息队列添加CALLBACK_TRAVERSAL绘制类型的待执行消息，用于触发后续UI线程真正实现绘制动作
         mChoreographer.postCallback(
                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);
         ...
     }
}
</code></pre><h4 id="322-收到vsync通知后调到relayoutwindow方法将msurfacecontrol序列化对象传入wms进程创建surfae">3.2.2 收到vsync通知后，调到relayoutWindow方法，将mSurfaceControl序列化对象传入wms进程创建surfae</h4>
<pre><code>/*frameworks/base/core/java/android/view/ViewRootImpl.java*/
void doTraversal() {
     if (mTraversalScheduled) {
         mTraversalScheduled = false;

         mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);
         ...
        // 1.执行具体的绘制任务
         performTraversals();
         ...
        // 2.从DecorView根节点出发，遍历整个View控件树，完成整个View控件树的layout测量操作
         performLayout(lp, mWidth, mHeight);
        ...
        // 3.从DecorView根节点出发，遍历整个View控件树，完成整个View控件树的draw测量操作
         performDraw();
     ...

    }
}

private void performTraversals() {
     ...
     // 1.1 从DecorView根节点出发，遍历整个View控件树，完成整个View控件树的measure测量操作
     windowSizeMayChange |= measureHierarchy(...);
     ...
     if (mFirst...) {
    // 1.2 第一次执行traversals绘制任务时，Binder调用访问系统窗口管理服务WMS的relayoutWindow接口，实现WMS计算应用窗口尺寸并向系统surfaceflinger正式申请Surface“画布”操作
         relayoutResult = relayoutWindow(params, viewVisibility, insetsPending);
     }
     ....
     //1.3 将surface通过RenderProxy传递给RenderThread
     hwInitialized = mAttachInfo.mThreadedRenderer.initialize(mSurface);
     ...
     //1.4 app层开始走绘制流程
     performDraw()；
     ...
}

private int relayoutWindow(WindowManager.LayoutParams params, int viewVisibility,
            boolean insetsPending) throws RemoteException {
        ...
        // 1.2.1通过Binder IPC访问系统WMS服务的relayout接口，申请Surface
        int relayoutResult = mWindowSession.relayout(mWindow, mSeq, params,
                (int) (mView.getMeasuredWidth() * appScale + 0.5f),
                (int) (mView.getMeasuredHeight() * appScale + 0.5f), viewVisibility,
                insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : 0, frameNumber,
                mTmpFrame, mTmpRect, mTmpRect, mTmpRect, mPendingBackDropFrame,
                mPendingDisplayCutout, mPendingMergedConfiguration, mSurfaceControl, mTempInsets,
                mTempControls, mSurfaceSize, mBlastSurfaceControl);
        if (mSurfaceControl.isValid()) {
            if (!useBLAST()) {
                // 1.2.3 本地Surface对象获取指向远端分配的Surface的引用
                mSurface.copyFrom(mSurfaceControl);
            } else {
               ...
            }
        }
        ...
}
</code></pre><h4 id="323-jni调用创建surface">3.2.3 jni调用创建surface</h4>
<p>接3.2.2 来到wms进程，最终通过jni调用（android_view_SurfaceControl类），来到native cleint端（libgui库）创建SurfaceComposerClient对象并和surfaceflinger进程 connect。</p>
<pre><code>/*frameworks/base/core/jni/android_view_SurfaceControl.cpp*/
static jlong nativeCreate(JNIEnv* env, jclass clazz, jobject sessionObj,
        jstring nameStr, jint w, jint h, jint format, jint flags, jlong parentObject,
        jobject metadataParcel) {
    ScopedUtfChars name(env, nameStr);//Surface名字， 在SurfaceFlinger侧就是Layer的名字
    ......
    sp&lt;SurfaceComposerClient&gt; client;
    ......
    status_t err = client-&gt;createSurfaceChecked(
            String8(name.c_str()), w, h, format, &amp;surface, flags, parent, std::move(metadata));
    ......
}

/*frameworks/native/libs/gui/SurfaceComposerClient.cpp*/
status_t SurfaceComposerClient::createSurfaceChecked(const String8&amp; name, uint32_t w, uint32_t h,
                                                     PixelFormat format,
                                                     sp&lt;SurfaceControl&gt;* outSurface, uint32_t flags,
                                                     SurfaceControl* parent, LayerMetadata metadata,
                                                     uint32_t* outTransformHint) {
      ......
      err = mClient-&gt;createSurface(name, w, h, format, flags, parentHandle, std::move(metadata),
                                     &amp;handle, &amp;gbp, &amp;transformHint);
      ......
｝
开始binder跨进程调用
/frameworks/native/libs/gui/ISurfaceComposerClient.cpp*/
status_t createSurface(const String8&amp; name, uint32_t width, uint32_t height, PixelFormat format,
                           uint32_t flags, const sp&lt;IBinder&gt;&amp; parent, LayerMetadata metadata,
                           sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp,
                           uint32_t* outTransformHint) override {
     return callRemote&lt;decltype(&amp;ISurfaceComposerClient::createSurface)&gt;(Tag::CREATE_SURFACE,
                               name, width, height,
                               format, flags, parent,
                               std::move(metadata),
                               handle, gbp,
                               outTransformHint);
}
</code></pre><h4 id="324-sf测创建layer和app进程的surface一一对应">3.2.4 sf测创建layer和app进程的surface一一对应</h4>
<p>接3.2.3来到Surfaceflinger进程，在sf测创建layer和bufferqueue对象，最后WMS的createSurfaceControl方法中是通过getSurfaceControl将SurfaceControll传出来的给到app进程共用。引用沧浪之水的一张图看看SF创建layer的过程

  <img src="/img/sf%E5%88%9B%E5%BB%BAsurface.jpg" alt="SF创建layer过程">

</p>
<pre><code>/*frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp*/
status_t SurfaceFlinger::createLayer(const String8&amp; name, const sp&lt;Client&gt;&amp; client, uint32_t w,
                                     uint32_t h, PixelFormat format, uint32_t flags,
                                     LayerMetadata metadata, sp&lt;IBinder&gt;* handle,
                                     sp&lt;IGraphicBufferProducer&gt;* gbp,
                                     const sp&lt;IBinder&gt;&amp; parentHandle, const sp&lt;Layer&gt;&amp; parentLayer,
                                     uint32_t* outTransformHint) {
    .....
    sp&lt;Layer&gt; layer;

    std::string uniqueName = getUniqueLayerName(name.string());

    bool primaryDisplayOnly = false;

    // window type is WINDOW_TYPE_DONT_SCREENSHOT from SurfaceControl.java
    // TODO b/64227542
    if (metadata.has(METADATA_WINDOW_TYPE)) {
        int32_t windowType = metadata.getInt32(METADATA_WINDOW_TYPE, 0);
        if (windowType == 441731) {
            metadata.setInt32(METADATA_WINDOW_TYPE, InputWindowInfo::TYPE_NAVIGATION_BAR_PANEL);
            primaryDisplayOnly = true;
        }
    }

    switch (flags &amp; ISurfaceComposerClient::eFXSurfaceMask) {
        case ISurfaceComposerClient::eFXSurfaceBufferQueue:
            //创建sf测layer，本质上创建一个bufferqueue（sf进程和app进程共用）
            result = createBufferQueueLayer(client, std::move(uniqueName), w, h, flags,
                                            std::move(metadata), format, handle, gbp, &amp;layer);

            break;
            ......
    }
    .....
    bool addToCurrentState = callingThreadHasUnscopedSurfaceFlingerAccess();
    //创建的layer，保存到CurrentState.layersSortedByZ
    result = addClientLayer(client, *handle, *gbp, layer, parentHandle, parentLayer,
                            addToCurrentState, outTransformHint);
    if (result != NO_ERROR) {
        return result;
    }
    .....
    return result;
}

/*frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp*/

status_t SurfaceFlinger::addClientLayer(const sp&lt;Client&gt;&amp; client, const sp&lt;IBinder&gt;&amp; handle,
                                        const sp&lt;IGraphicBufferProducer&gt;&amp; gbc, const sp&lt;Layer&gt;&amp; lbc,
                                        const sp&lt;IBinder&gt;&amp; parentHandle,
                                        const sp&lt;Layer&gt;&amp; parentLayer, bool addToCurrentState,
                                        uint32_t* outTransformHint) {
    // add this layer to the current state list
    {
        Mutex::Autolock _l(mStateLock);
        sp&lt;Layer&gt; parent;
        ......

        if (parent == nullptr &amp;&amp; addToCurrentState) {
            //CurrentState.layersSortedByZ代表sf测创建的layer列表
            mCurrentState.layersSortedByZ.add(lbc);
        } 
        .....
    
    }
    .....

    return NO_ERROR;
}

</code></pre><h3 id="33-绘制详细内容参考绘制篇">3.3 绘制（详细内容参考绘制篇）</h3>
<p>创建surface/layer后，这时候layer中的buffer 是空的。接3.2.2的部分最终到renderthrea线程，通过layer申请buffer，绘制，并提交buffer。（下一篇重点分析）。</p>
<h3 id="34-根据layer所属的displayid创建hwc-client对应的hwc2layer">3.4 根据layer所属的displayid创建HWC client对应的HWC2::layer</h3>
<p>sf测收到vsync-sf信号后，去当前对应layers数组中查找可以合成的layer,并创建hwc client对应的hwc2::layer。</p>
<h4 id="341-sf收到vsync信号后">3.4.1 sf收到vsync信号后</h4>
<pre><code>/*frameworks/native/services/surfaceflinger/Surfaceflinger.cpp*/

//收到vsync信号
void SurfaceFlinger::onMessageReceived(int32_t what, nsecs_t expectedVSyncTime) {
    ATRACE_CALL();
    switch (what) {
        case MessageQueue::INVALIDATE: {
            //1 处理事务和buffer更换（合成篇重点讲解 ），并最终发送REFRESH消息走到onMessageRefresh方法
            onMessageInvalidate(expectedVSyncTime);
            break;
        }
        case MessageQueue::REFRESH: {
            //2 开始合成
            onMessageRefresh();
            break;
        }
    }
}

void SurfaceFlinger::onMessageRefresh() {
    ATRACE_CALL();

    mRefreshPending = false;

    compositionengine::CompositionRefreshArgs refreshArgs;
    // 0 这里的mDisplays数组是显示屏幕数量（包括虚拟屏）合成篇重点讲解这个数组的数据如何通过监听热插拔信号拿到。
    const auto&amp; displays = ON_MAIN_THREAD(mDisplays);
     // 1.1 保存当前displaydevice 数组
    refreshArgs.outputs.reserve(displays.size());
    for (const auto&amp; [_, display] : displays) {
        refreshArgs.outputs.push_back(display-&gt;getCompositionDisplay());
    }
    // 1.2 保存当前layer数组
    mDrawingState.traverseInZOrder([&amp;refreshArgs](Layer* layer) {
        if (auto layerFE = layer-&gt;getCompositionEngineLayerFE())
            refreshArgs.layers.push_back(layerFE);
    });
    // 1.3 保存当前前有queueframes（有Buffer）的layer数组
    refreshArgs.layersWithQueuedFrames.reserve(mLayersWithQueuedFrames.size());
    for (sp&lt;Layer&gt; layer : mLayersWithQueuedFrames) {
        if (auto layerFE = layer-&gt;getCompositionEngineLayerFE())
            refreshArgs.layersWithQueuedFrames.push_back(layerFE);
    }
 
    ...
    // 1.3 核心逻辑
    mCompositionEngine-&gt;present(refreshArgs);
   }

</code></pre><h4 id="342-hwc-client创建需要合成的hwc2layer">3.4.2 HWC client创建需要合成的HWC2::Layer</h4>
<p>接3.4.1 来到CompositionEngine类的prepare方法</p>
<pre><code>/*frameworks/native/services/surfaceflinger/CompositionEngine/src/CompositionEngine.cpp*/

void CompositionEngine::present(CompositionRefreshArgs&amp; args) {
    ATRACE_CALL();
    ALOGV(__FUNCTION__);
    ...
    {
        // latchedLayers is used to track the set of front-end layer state that
        // has been latched across all outputs for the prepare step, and is not
        // needed for anything else.
        LayerFESet latchedLayers;

        for (const auto&amp; output : args.outputs) {
            // 1 计算各个layer的可视区域以及创建hwc layer
            output-&gt;prepare(args, latchedLayers);
        }
    }
    // 2更新layerCompositionState
    updateLayerStateFromFE(args);

    for (const auto&amp; output : args.outputs) {
        // 3
        output-&gt;present(args);
    }
}

void Output::prepare(const compositionengine::CompositionRefreshArgs&amp; refreshArgs,
                     LayerFESet&amp; geomSnapshots) {
    ATRACE_CALL();
    ALOGV(__FUNCTION__);
    // 1.1 计算layer的可视区域和遮挡区域
    rebuildLayerStacks(refreshArgs, geomSnapshots);
}

/*frameworks/native/services/surfaceflinger/CompositionEngine/src/Output.cpp*/
1.1 重新构建Layer栈计算可视区
void Output::rebuildLayerStacks(const compositionengine::CompositionRefreshArgs&amp; refreshArgs,
                                LayerFESet&amp; layerFESet) {
    ATRACE_CALL();
    ALOGV(__FUNCTION__);
    ...
    // Process the layers to determine visibility and coverage
    compositionengine::Output::CoverageState coverage{layerFESet};
    collectVisibleLayers(refreshArgs, coverage);
    ...
}

void Output::collectVisibleLayers(const compositionengine::CompositionRefreshArgs&amp; refreshArgs,
                                  compositionengine::Output::CoverageState&amp; coverage) {
    // Evaluate the layers from front to back to determine what is visible. This
    // also incrementally calculates the coverage information for each layer as
    // well as the entire output.
    //1.1.1 遍历当前所有layer
    for (auto layer : reversed(refreshArgs.layers)) {
        // Incrementally process the coverage for each layer
        ensureOutputLayerIfVisible(layer, coverage);
        ...
    }

    setReleasedLayers(refreshArgs);

    finalizePendingOutputLayers();
}

OutputLayer* ensureOutputLayer(std::optional&lt;size_t&gt; prevIndex,
                                       const sp&lt;LayerFE&gt;&amp; layerFE) {

            // 1.1.1.1 判断当前的outputlayer 集合里面有没有当前的layer，如果没有则新创建一个可视layer
            auto outputLayer = (prevIndex &amp;&amp; *prevIndex &lt;= mCurrentOutputLayersOrderedByZ.size())
                    ? std::move(mCurrentOutputLayersOrderedByZ[*prevIndex])
                    : BaseOutput::createOutputLayer(layerFE);
            auto result = outputLayer.get();
            mPendingOutputLayersOrderedByZ.emplace_back(std::move(outputLayer));
            return result;
        }


/*frameworks/native/services/surfaceflinger/CompositionEngine/src/Display.cpp*/

std::unique_ptr&lt;compositionengine::OutputLayer&gt; Display::createOutputLayer(
        const sp&lt;compositionengine::LayerFE&gt;&amp; layerFE) const {
    auto result = impl::createOutputLayer(*this, layerFE);

    if (result &amp;&amp; mId) {
        auto&amp; hwc = getCompositionEngine().getHwComposer();
        auto displayId = *mId;
        // 1.1.1.1.1 根据当前layer所属的display创建一一对应的HWC2::layer
        auto hwcLayer = std::shared_ptr&lt;HWC2::Layer&gt;(hwc.createLayer(displayId),
                                                     [&amp;hwc, displayId](HWC2::Layer* layer) {
                                                         hwc.destroyLayer(displayId, layer);
                                                     });
        // 更新state.hwc
        result-&gt;setHwcLayer(std::move(hwcLayer));
    }
    return result;
}
</code></pre><h3 id="35通过hwc-client的hwc2layer调用hwc-servcie创建layer">3.5通过HWC client的HWC2::layer调用HWC servcie创建layer。</h3>
<h4 id="351-接341的-11111来到outputcpp的present方法">3.5.1 接3.4.1的 1.1.1.1.1，来到output.cpp的present方法</h4>
<p>最终来到ComposerHal的createLayer方法</p>
<pre><code>/*frameworks/native/services/surfaceflinger/DisplayHardware/ComposerHal.cpp*/
Error Composer::createLayer(Display display, Layer* outLayer)
{
    Error error = kDefaultError;
    mClient-&gt;createLayer(display, BufferQueue::NUM_BUFFER_SLOTS,
            [&amp;](const auto&amp; tmpError, const auto&amp; tmpLayer) {
                error = tmpError;
                if (error != Error::NONE) {
                    return;
                }

                *outLayer = tmpLayer;
            });

    return error;
}
</code></pre><h4 id="352-接351调到hidl-so接口库的hwchalh中createlayer方法">3.5.2 接3.5.1，调到hidl so接口库的HwcHal.h中createLayer方法</h4>
<pre><code>/*hardware/interfaces/graphics/composer/2.1/utils/passthrough/include/composer-passthrough/2.1/HwcHal.h*/

    Error createLayer(Display display, Layer* outLayer) override {
        int32_t err = mDispatch.createLayer(mDevice, display, outLayer);
        return static_cast&lt;Error&gt;(err);
    }

</code></pre><h4 id="353-接352调到hwc-service厂商实现库中hwc_sessioncpp的pcreatelayer方法">3.5.3 接3.5.2，调到HWC Service厂商实现库中hwc_session.cpp的pcreateLayer方法</h4>
<pre><code>/*hardware/qcom/sdm845/display/sdm/libs/hwc2/hwc_session.cpp*/
int32_t HWCSession::CreateLayer(hwc2_device_t *device, hwc2_display_t display,
                                hwc2_layer_t *out_layer_id) {
  if (!out_layer_id) {
    return  HWC2_ERROR_BAD_PARAMETER;
  }

  return CallDisplayFunction(device, display, &amp;HWCDisplay::CreateLayer, out_layer_id);
}
</code></pre><h3 id="36-接34-output类的presentargs方法最终合成合成篇讲解">3.6 接3.4 output类的present(args)方法，最终合成。（合成篇讲解）</h3>
<p>有2种合成类型，一是client合成（gpu合成，会单独创建一个FramebufferSuface队列，直接绘制多个buffer到屏幕，最终给到HWC和其他overlayer一起合成，会单独讲解），两一个是hwc合成。</p>
<pre><code>void Output::present(const compositionengine::CompositionRefreshArgs&amp; refreshArgs) {
    ATRACE_CALL();
    ......
    //1.告知HWC service有哪些layer要参与合成
    updateAndWriteCompositionState(refreshArgs);
    ......
    beginFrame();
    prepareFrame();
    ......
    finishFrame(refreshArgs);
    //2.这里会调用到HWC service的接口去present display合成画面
    postFramebuffer();
}
void Output::postFramebuffer() {
    ......
    auto frame = presentAndGetFrameFences();
    ......
}

/*frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp*/

status_t HWComposer::presentAndGetReleaseFences(DisplayId displayId) {
    ATRACE_CALL();
    ......
    //2.1 送去HWC service合成
    auto error = hwcDisplay-&gt;present(&amp;displayData.lastPresentFence);
    ......
    std::unordered_map&lt;HWC2::Layer*,sp&lt;Fence&gt;&gt; releaseFences;
    error = hwcDisplay-&gt;getReleaseFences(&amp;releaseFences);
    RETURN_IF_HWC_ERROR_FOR(&quot;getReleaseFences&quot;, error, displayId, UNKNOWN_ERROR);

    displayData.releaseFences = std::move(releaseFences);//获取releaseFence, 以便通知到各个Slot, buffer被release后会通过dequeueBuffer给到应用，应用在绘图前会等待releaseFence
    ......
}

</code></pre><h3 id="37-hwc-server调用drm创建planes待继续学习">3.7 HWC server调用drm创建planes待继续学习。</h3>


                
                
<div class="entry-shang text-center">
    
	    <p>「真诚赞赏，手留余香」</p>
	
	<button class="zs show-zs btn btn-bred">赞赏支持</button>
</div>
<div class="zs-modal-bg"></div>
<div class="zs-modal-box">
	<div class="zs-modal-head">
		<button type="button" class="close">×</button>
		<span class="author"><a href="https://ywqyunshan.github.io/"><img src="/img/favicon.png" />FQ Blog</a></span>
        
	        <p class="tip"><i></i><span>真诚赞赏，手留余香</span></p>
		
 
	</div>
	<div class="zs-modal-body">
		<div class="zs-modal-btns">
			<button class="btn btn-blink" data-num="2">2元</button>
			<button class="btn btn-blink" data-num="5">5元</button>
			<button class="btn btn-blink" data-num="10">10元</button>
			<button class="btn btn-blink" data-num="50">50元</button>
			<button class="btn btn-blink" data-num="100">100元</button>
			<button class="btn btn-blink" data-num="1">任意金额</button>
		</div>
		<div class="zs-modal-pay">
			<button class="btn btn-bred" id="pay-text">2元</button>
			<p>使用<span id="pay-type">微信</span>扫描二维码完成支付</p>
			<img src="/img/reward/wechat-2.png"  id="pay-image"/>
		</div>
	</div>
	<div class="zs-modal-footer">
		<label><input type="radio" name="zs-type" value="wechat" class="zs-type" checked="checked"><span ><span class="zs-wechat"><img src="/img/reward/wechat-btn.png"/></span></label>
		<label><input type="radio" name="zs-type" value="alipay" class="zs-type" class="zs-alipay"><img src="/img/reward/alipay-btn.png"/></span></label>
	</div>
</div>
<script type="text/javascript" src="/js/reward.js"></script>

                

                
                <hr>
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2023/01/19/" data-toggle="tooltip" data-placement="top" title="Android图形系统-架构">&larr;
                            Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2023/02/22/" data-toggle="tooltip" data-placement="top" title="Android图形系统-渲染子系统">Next
                            Post &rarr;</a>
                    </li>
                    
                </ul>
                

                



            </div>

            
            
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
            

            
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                
                
                <section>
                    <hr class="hidden-sm hidden-xs">
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                        
                        
                        
                        <a href="/tags/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98" title="工程实战">
                            工程实战
                        </a>
                        
                        
                        
                        <a href="/tags/%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA" title="系统理论">
                            系统理论
                        </a>
                        
                        
                    </div>
                </section>
                

                
                
                <section>
                    <hr>
                    <h5>FRIENDS</h5>
                    <ul class="list-inline">
                        
                        <li><a target="_blank" href="https://www.jianshu.com/u/e9dc7e422257">iigeoywq的博客</a></li>
                        
                        <li><a target="_blank" href="https://www.jianshu.com/u/978b4a822bc3">button的博客</a></li>
                        
                    </ul>
                </section>
                
            </div>
        </div>
    </div>
</article>




<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">                  
                    
                    <li>
                        <a href="mailto:youremail@gmail.com">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		           
                    
                    
                    
                    

		            
                    
                    <li>
                        <a target="_blank" href="/your%20wechat%20qr%20code%20image">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fab fa-weixin fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		            
                    
                    <li>
                        <a target="_blank" href="https://github.com/yourgithub">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		            
                    
                    
                    
                    <li>
                        <a target="_blank" href="https://www.linkedin.com/in/yourlinkedinid">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fab fa-linkedin fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		           
                    
                    
                    <li>
                        <a target="_blank" href="https://stackoverflow.com/users/yourstackoverflowid">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fab fa-stack-overflow fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    
                    
                    
            
            
            
           
                   <li>
                       <a href='' rel="alternate" type="application/rss+xml" title="FQ Blog" >
                           <span class="fa-stack fa-lg">
                               <i class="fas fa-circle fa-stack-2x"></i>
                               <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
                           </span>
                       </a>
                   </li>
            
             </ul>
		<p class="copyright text-muted">
                    Copyright &copy; FQ Blog 2025
                    <br>
                    <a href="https://themes.gohugo.io/hugo-theme-cleanwhite">CleanWhite Hugo Theme</a> by <a href="https://zhaohuabing.com">Huabing</a> |
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="100px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=zhaohuabing&repo=hugo-theme-cleanwhite&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>




<script>
    function loadAsync(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>






<script>
    
    if($('#tag_cloud').length !== 0){
        loadAsync("/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>


<script>
    loadAsync("https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>






<script type="text/javascript">
    function generateCatalog(selector) {

        
        
        
        
            _containerSelector = 'div.post-container'
        

        
        var P = $(_containerSelector), a, n, t, l, i, c;
        a = P.find('h1,h2,h3,h4,h5,h6');

        
        $(selector).html('')

        
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#" + $(this).prop('id');
            t = $(this).text();
            c = $('<a href="' + i + '" rel="nofollow">' + t + '</a>');
            l = $('<li class="' + n + '_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;
    }

    generateCatalog(".catalog-body");

    
    $(".catalog-toggle").click((function (e) {
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    


    loadAsync("\/js\/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>






</body>
</html>
